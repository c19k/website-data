// Summarizes data for site.
const _ = require('lodash')
const moment = require('moment')

const verify = require('./verify.js')

const utils = require('./utils');

const todayIndiaString = moment().utcOffset(330).format('YYYY-MM-DD')

// const lastDay = moment().utcOffset(330)

// Merge all the data from the spreadsheet with auto-calculation
//
// patientData: Output generated by fetchPatientData
// manualDailyData: List of rows from the Sum By Day spreadsheet.
// manualPrefectureData: List of rows from the Prefecture Data spreadsheet
// lastUpdated: String representing when the data was last updated.
//
// @returns A dictionary with the prefecture and daily summaries.
const summarize = (patientData, manualDailyData, manualPrefectureData, lastUpdated, ageStatusData, genderStatusData, underObservationData) => {
  const patients = _.orderBy(patientData, ['dateAnnounced'], ['asc'])
  let prefectureSummary = generatePrefectureSummary(patients, manualPrefectureData)
  let dailySummary = generateDailySummary(patients, manualDailyData)
  let sortedManualDailyData = _.orderBy(manualDailyData, ['date'],['asc']);
  let kpiData = generateKpiSummary(sortedManualDailyData);
  let ageStatus = generateAgeStatus(ageStatusData);
  let underObservationSummary = generateUnderObservationSummary(underObservationData);
  return {
    updated: lastUpdated,
    prefectures: prefectureSummary,
    daily: dailySummary,
    age: ageStatus,
    gender: genderStatusData,
    underObservation: underObservationSummary,
    kpiData : kpiData
  };
}


// Helper method to do parseInt safely (reverts to 0 if unparse)
const safeParseInt = v => {
  let result = parseInt(v)
  if (isNaN(result)) {
    return 0
  }
  return result
}
const generateKpiSummary = (manualDailyData) => {
  return utils.calculateTotals(manualDailyData);
} 
const generateAgeStatus = (ageStatusData) => {
  let ageStatus = []
  for (let row of ageStatusData) {
      let ageStatusGroup = {}
      ageStatusGroup.ageGroup = row.agegroup
      ageStatusGroup.female = safeParseInt(row.female)
      ageStatusGroup.male = safeParseInt(row.male)
      ageStatusGroup.unspecified = safeParseInt(row.unspecified)
      ageStatusGroup.total = safeParseInt(row.total)
      ageStatus.push(ageStatusGroup)
  }
  return ageStatus
}

// Generates the daily summary
const generateDailySummary = (patients, manualDailyData) => {
  let dailySummary = {}
  for (let patient of patients) {
    let dateAnnounced = patient.dateAnnounced
    if (!patient.dateAnnounced) {
      continue
    }
    if (!dailySummary[dateAnnounced]) {
      dailySummary[dateAnnounced] = {
        confirmed: 0,
        recoveredCumulative: 0,
        deceasedCumulative: 0,
        criticalCumulative: 0,
        testedCumulative: 0,
        observationCumulative: 0,
        homeObservationCumulative: 0,
        hosptilisedCumulative:0,
        activeCumulative:0,
      }
    }

    if (!dailySummary[todayIndiaString]) {
      dailySummary[todayIndiaString] = {
        confirmed: 0,
        recoveredCumulative: 0,
        deceasedCumulative: 0,
        criticalCumulative: 0,
        testedCumulative: 0,
        observationCumulative: 0,
        homeObservationCumulative: 0,
        hosptilisedCumulative:0,
        activeCumulative:0,
      }
    }

    if (patient.confirmedPatient) {
      dailySummary[dateAnnounced].confirmed += 1
    }
  }

  // override with manually sourced data if they are available
  for (let i=0; i< manualDailyData.length; i++) {
    let row = manualDailyData[i];
    
    if (!row.date) {
      continue;
    }
    let lastDayData = false;
    if(i>0){
      lastDayData = manualDailyData[i-1];
    }
    let dateTs = moment(row.date).format('X');
    let aprilTs = moment('2020-04-01').format('X');
    let isBeforeAprilFirst = aprilTs > dateTs;
    //no need to add entry if the number of confirmed cases are 0 for that date
    //and the date is before april 1st
    if (isBeforeAprilFirst && !dailySummary[row.date]) {
      continue;
    } 
      if (!dailySummary[row.date]) {
        dailySummary[row.date] = {
          confirmed: 0,
          recoveredCumulative: 0,
          deceasedCumulative: 0,
          criticalCumulative: 0,
          testedCumulative: 0,
          observationCumulative: 0,
          homeObservationCumulative: 0,
          hosptilisedCumulative: 0,
          activeCumulative: 0,
        };
      }
      //We are storing cumulated value in confirmed cell. Hence needs to calculate the difference with the last day to
      //get the difference
      let lastDayConfirmed = _.get(lastDayData, 'confirmed', 0);
      dailySummary[row.date].confirmed = safeParseInt(row.confirmed - lastDayConfirmed)

      
      dailySummary[row.date].recoveredCumulative = safeParseInt(row.recovered)
      dailySummary[row.date].deceasedCumulative = safeParseInt(row.deceased)
      dailySummary[row.date].criticalCumulative = safeParseInt(row.critical)
      dailySummary[row.date].testedCumulative = safeParseInt(row.tested)
      dailySummary[row.date].observationCumulative = safeParseInt(row.observation)
      dailySummary[row.date].homeObservationCumulative = safeParseInt(row.homeobservation)
      dailySummary[row.date].hosptilisedCumulative = safeParseInt(row.hosptilised)
      dailySummary[row.date].activeCumulative = safeParseInt(row.active)
      dailySummary[row.date].importedCases = safeParseInt(row.import);
      dailySummary[row.date].contactCases = safeParseInt(row.contact);
      dailySummary[row.date].noHistoryCases = safeParseInt(row.nohistory);
      dailySummary[row.date].criticalCases = safeParseInt(row.critial);
      dailySummary[row.date].status = row.status
    
  }

  let orderedDailySummary = 
      _.map(_.sortBy(_.toPairs(dailySummary), a => a[0]), (v) => { let o = v[1]; o.date = v[0]; return o })
  
  // Calculate the confirmedCumulative by iterating through all the days in order
  let confirmedCumulative = 0
  for (let dailySum of orderedDailySummary) {
    confirmedCumulative += dailySum.confirmed
    dailySum.confirmedCumulative = confirmedCumulative
  }

  // Calculate a rolling 3/7 day average for confirmed.
  let threeDayBuffer = []
  let sevenDayBuffer = []
  let confirmedCumulativeAvg3d = 0
  let confirmedCumulativeAvg7d = 0
  for (let dailySum of orderedDailySummary) {
    threeDayBuffer.push(dailySum.confirmed)
    sevenDayBuffer.push(dailySum.confirmed)
    if (threeDayBuffer.length > 3) {
      threeDayBuffer = threeDayBuffer.slice(threeDayBuffer.length - 3)
    }
    if (sevenDayBuffer.length > 7) {
      sevenDayBuffer = sevenDayBuffer.slice(sevenDayBuffer.length - 7) 
    }
    dailySum.confirmedAvg3d = Math.floor(_.sum(threeDayBuffer) / 3)
    confirmedCumulativeAvg3d += dailySum.confirmedAvg3d
    dailySum.confirmedCumulativeAvg3d = confirmedCumulativeAvg3d

    dailySum.confirmedAvg7d = Math.floor(_.sum(sevenDayBuffer) / 7)
    confirmedCumulativeAvg7d += dailySum.confirmedAvg7d
    dailySum.confirmedCumulativeAvg7d = confirmedCumulativeAvg7d
  }

  // For dates we don't have any manually entered data, pass those forward.
  for (let i = 1; i < orderedDailySummary.length; i++) {
    let thisDay = orderedDailySummary[i]
    let previousDay = orderedDailySummary[i-1]
    if (thisDay.recoveredCumulative == 0) {
      thisDay.recoveredCumulative = previousDay.recoveredCumulative
    }
    if (thisDay.deceasedCumulative == 0) {
      thisDay.deceasedCumulative = previousDay.deceasedCumulative
    }
    if (thisDay.criticalCumulative == 0) {
      thisDay.criticalCumulative = previousDay.criticalCumulative
    }
    if (thisDay.testedCumulative == 0) {
      thisDay.testedCumulative = previousDay.testedCumulative
    }
    if (thisDay.observationCumulative == 0) {
      thisDay.observationCumulative = previousDay.observationCumulative
    }
    if (thisDay.homeObservationCumulative == 0) {
      thisDay.homeObservationCumulative = previousDay.homeObservationCumulative
    }
    if (thisDay.hosptilisedCumulative == 0) {
      thisDay.hosptilisedCumulative = previousDay.hosptilisedCumulative
    }
    if (thisDay.activeCumulative == 0) {
      thisDay.activeCumulative = previousDay.activeCumulative
    }
  }


  orderedDailySummary = verify.verifyDailySummary(orderedDailySummary)
  return orderedDailySummary
}


// Generate the per-prefecture summary, ordered by number of confirmed cases.
//
// patients: Patients data from Patient Data spreadsheet.
// manualPrefectureData: List of rows from the prefecture spreadsheet.
//
// @returns prefectureSummary as a dictionary.
const generatePrefectureSummary = (patients, manualPrefectureData) => {
  let prefectureSummary = {}

  for (let patient of patients) {
    let prefectureName = patient.detectedPrefecture
    let cityName = patient.detectedCityTown

    if (!prefectureSummary[prefectureName]) {
      prefectureSummary[prefectureName] = {
        confirmed: 0,
        // cruisePassenger: 0,
        // cruiseWorker: 0,
        deaths: 0,
        patients: [],
        confirmedByCity: {}
      }
    }

    if (patient.confirmedPatient) {
      prefectureSummary[prefectureName].confirmed += 1
      if (cityName) {
        if (prefectureSummary[prefectureName].confirmedByCity[cityName]) {
          prefectureSummary[prefectureName].confirmedByCity[cityName] += 1
        } else {
          prefectureSummary[prefectureName].confirmedByCity[cityName] = 1        
        }
      }

      /*if (patient.cruisePassengerDisembarked == 1) {
        prefectureSummary[prefectureName].cruisePassenger += 1
      }
      if (patient.cruiseQuarantineOfficer == 1) {
        prefectureSummary[prefectureName].cruiseWorker += 1
      }*/

    }

    if (patient.patientStatus == 'Deceased') {
      prefectureSummary[prefectureName].deaths += 1
    }

    prefectureSummary[prefectureName].patients.push(patient)
  }

  for (let prefectureName of _.keys(prefectureSummary)) {
    let prefecture = prefectureSummary[prefectureName]
    const firstDay = moment('2020-01-31')
    const dailyConfirmed = generateDailyStatsForPrefecture(prefecture.patients, firstDay)
    if (dailyConfirmed && dailyConfirmed.length) {
      prefecture.dailyConfirmedCount = dailyConfirmed
      prefecture.dailyConfirmedStartDate = firstDay.format('YYYY-MM-DD')
      prefecture.newlyConfirmed = dailyConfirmed[dailyConfirmed.length - 1]
    }
  }

  // Import manual data.
  for (let row of manualPrefectureData) {
    if (prefectureSummary[row.district]) {
      prefectureSummary[row.district].recovered = safeParseInt(row.recovered)
      prefectureSummary[row.district].deaths = safeParseInt(row.deaths)
      prefectureSummary[row.district].name_ja = row.districtml
      prefectureSummary[row.district].zone = row.zone
      prefectureSummary[row.district].zoneUpdatedOn = row.zoneupdatedon
    }
  }

  // Strip out patients list
  prefectureSummary = _.mapValues(prefectureSummary, (v, k) => { 
    delete v['patients']
    return v
  })

  return _.map(
    _.reverse(
      _.sortBy(
        _.toPairs(prefectureSummary), 
        [ a => a[1].confirmed ])),
    (v) => { let o = v[1]; o.name = v[0]; return o }
  )
}

const generateDailyStatsForPrefecture = (patients, firstDay) => {
  const lastDay = moment().utcOffset(330)
  let day = moment(firstDay)
  let daily = []
  while (day <= lastDay) {
    let dayString = day.format('YYYY-MM-DD')
    let reports = _.filter(patients, o => { return o.dateAnnounced == dayString })
    daily.push(reports.length)
    day = day.add(1, 'days')
  }
  return daily
}

const generateUnderObservationSummary = (underObservationData) => {
  let underObservationMap = {};
  for (let row of underObservationData) {
    let district = row["district"];
    let date = row["date"];
    if (underObservationMap[date]) {
      underObservationMap[date][district] = row;
    } else {
      underObservationMap[date] = {};
      underObservationMap[date][district] = row;
    }
  }
  let validDates = Object.keys(underObservationMap);
  validDates.sort();

  let summarisedData = {};

  for (let i = 0; i < validDates.length; i++) {
    let date = validDates[i];
    let prevDate = i == 0 ? false : validDates[i - 1];
    let dataForDate = underObservationMap[date];
    let dataForPreviousDate = i == 0 ? false : underObservationMap[prevDate];
    let totalForDate = {
      peopleunderobservation: 0,
      homeisolation: 0,
      hospitalisolation: 0,
    };

    let dateSummary = {};

    for (district in dataForDate) {
      let prevDayPeopleUnderObservation =
        i == 0
          ? 0
          : safeParseInt(dataForPreviousDate[district]["peopleunderobservation"]);
      let prevDayPeopleHomeIsolation =
        i == 0 ? 0 : safeParseInt(dataForPreviousDate[district]["homeisolation"]);
      let prevDayPeopleHospitalIsolation =
        i == 0
          ? 0
          : safeParseInt(dataForPreviousDate[district]["hospitalisolation"]);

      let deltaPeopleUnderObservation =
        safeParseInt(dataForDate[district]["peopleunderobservation"]) -
        prevDayPeopleUnderObservation;

      let deltaHomeIsolation =
        safeParseInt(dataForDate[district]["homeisolation"]) -
        prevDayPeopleHomeIsolation;

      let deltaHospitalIsolation =
        safeParseInt(dataForDate[district]["hospitalisolation"]) -
        prevDayPeopleHospitalIsolation;

      totalForDate.homeisolation += safeParseInt(
        dataForDate[district]["homeisolation"]
      );
      totalForDate.hospitalisolation += safeParseInt(
        dataForDate[district]["hospitalisolation"]
      );
      totalForDate.peopleunderobservation += safeParseInt(
        dataForDate[district]["peopleunderobservation"]
      );

      dateSummary[district] = {
        homeisolation: safeParseInt(dataForDate[district]["homeisolation"]),
        hospitalisolation: safeParseInt(dataForDate[district]["hospitalisolation"]),
        peopleunderobservation: safeParseInt(dataForDate[district]["peopleunderobservation"]),
        deltaPeopleUnderObservation,
        deltaHomeIsolation,
        deltaHospitalIsolation,
      };
    }
    let previousDaySummary = summarisedData[prevDate] ? summarisedData[prevDate] : false;
    if (previousDaySummary && previousDaySummary["total"]) {
      totalForDate.deltaPeopleUnderObservation =
        totalForDate["homeisolation"] -
        safeParseInt(previousDaySummary["total"]["homeisolation"]);
      totalForDate.deltaHomeIsolation =
        totalForDate["hospitalisolation"] -
        safeParseInt(previousDaySummary["total"]["hospitalisolation"]);
      totalForDate.deltaHospitalIsolation =
        totalForDate["peopleunderobservation"] -
        safeParseInt(previousDaySummary["total"]["peopleunderobservation"]);
    } else {
      totalForDate.deltaPeopleUnderObservation = safeParseInt(
        totalForDate["homeisolation"]
      );
      totalForDate.deltaHomeIsolation = safeParseInt(
        totalForDate["hospitalisolation"]
      );
      totalForDate.deltaHospitalIsolation = safeParseInt(
        totalForDate["peopleunderobservation"]
      );
    }
    dateSummary["total"] = totalForDate;

    summarisedData[date] = dateSummary;
  }
  return summarisedData;
};

exports.summarize = summarize;

